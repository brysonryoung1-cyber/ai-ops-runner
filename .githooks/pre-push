#!/usr/bin/env bash
# pre-push — UNBREAKABLE PUSH GATE (v2: ship-only + HMAC + canonical verdict)
#
# A push to origin/main requires ALL of:
#   1. OPENCLAW_SHIP=1 env var (set only by ops/ship.sh)
#   2. docs/LAST_APPROVED_VERDICT.json exists and is committed
#   3. range_end_sha == approved_head_sha (internal consistency)
#   4. range_end_sha matches the push HEAD:
#      - EXACT: range_end_sha == push HEAD, OR
#      - EXTENSION: range_end_sha == parent(push HEAD) and the only
#        diff is docs/LAST_APPROVED_VERDICT.json and/or docs/LAST_REVIEWED_SHA.txt
#   5. simulated == false
#   6. HMAC signature valid (fail-closed if VERDICT_HMAC_KEY unset)
#
# NO bypass env vars. NO direct git push. Simulated verdicts NEVER pass.
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel)"

# ── Read stdin (git push protocol) ──
PUSH_LOCAL_SHA=""
PUSH_REMOTE_SHA=""
while read -r local_ref local_sha remote_ref remote_sha; do
  if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
    continue
  fi
  if [ "$remote_ref" = "refs/heads/main" ]; then
    PUSH_LOCAL_SHA="$local_sha"
    PUSH_REMOTE_SHA="$remote_sha"
  fi
done

# Only enforce ship gate for pushes to main (allow pushes to other branches, e.g. ship/* for PR flow)
if [ -z "$PUSH_LOCAL_SHA" ]; then
  exit 0
fi

# ── Gate 0: Ship-only enforcement (main only) ──
if [ "${OPENCLAW_SHIP:-0}" != "1" ]; then
  echo "" >&2
  echo "========================================" >&2
  echo "  PUSH BLOCKED — direct push forbidden" >&2
  echo "========================================" >&2
  echo "  Only ops/ship.sh may push to main." >&2
  echo "  Run:  ./ops/ship.sh" >&2
  echo "" >&2
  exit 1
fi

TO="$PUSH_LOCAL_SHA"
echo "pre-push: Checking canonical verdict for push HEAD ${TO:0:12}"

# ── Load canonical verdict ──
VERDICT_PATH="$ROOT_DIR/docs/LAST_APPROVED_VERDICT.json"
if [ ! -f "$VERDICT_PATH" ]; then
  echo "" >&2
  echo "========================================" >&2
  echo "  PUSH BLOCKED — docs/LAST_APPROVED_VERDICT.json not found" >&2
  echo "========================================" >&2
  echo "  Run:  ./ops/ship.sh" >&2
  echo "" >&2
  exit 1
fi

# ── Strict gate validation (Python): tree-based attestation (squash-safe) ──
GATE_RC=0
python3 - "$VERDICT_PATH" "$TO" <<'PYEOF' || GATE_RC=$?
import json, sys, os, hmac, hashlib, subprocess

verdict_path = sys.argv[1]
TO = sys.argv[2]

with open(verdict_path) as f:
    v = json.load(f)

errors = []

# 1. Internal consistency: approved_head_sha == range_end_sha
approved = v.get("approved_head_sha", "")
range_end = v.get("range_end_sha", "")
approved_tree = v.get("approved_tree_sha", "")
if approved != range_end:
    errors.append(
        "internal inconsistency: approved_head_sha (%s) != range_end_sha (%s)"
        % (approved[:12], range_end[:12])
    )

# 2. approved_tree_sha: when present must be 40-hex. When missing, use legacy range_end gate (backward compat).
use_tree_gate = bool(approved_tree and len(approved_tree) == 40 and all(c in "0123456789abcdef" for c in approved_tree.lower()))
if approved_tree and not use_tree_gate:
    errors.append("approved_tree_sha invalid (must be 40-hex when present)")

def run_git(args, timeout=10):
    return subprocess.run(
        ["git"] + args,
        capture_output=True, text=True, timeout=timeout, check=False
    )

# 3. Gate: tree-based (when approved_tree_sha present) or legacy range_end + allowlist
tree_ok = False
if not errors:
    try:
        if use_tree_gate:
            head_tree_result = run_git(["rev-parse", TO + "^{tree}"])
            if head_tree_result.returncode != 0:
                errors.append("git rev-parse HEAD^{tree} failed")
            else:
                local_head_tree = head_tree_result.stdout.strip()
                if local_head_tree == approved_tree:
                    tree_ok = True
                else:
                    diff_result = run_git(["diff", "--name-only", range_end, TO])
                    if diff_result.returncode != 0:
                        errors.append(
                            "range_end_sha (%s)..push HEAD (%s) diff failed"
                            % (range_end[:12], TO[:12])
                        )
                    else:
                        diff_files = sorted(f for f in diff_result.stdout.strip().split("\n") if f)
                        allowed = ["docs/LAST_APPROVED_VERDICT.json", "docs/LAST_REVIEWED_SHA.txt"]
                        if diff_files and all(f in allowed for f in diff_files):
                            tree_ok = True
                        else:
                            errors.append(
                                "approved_tree_sha (%s) != push HEAD tree (%s); diff: %s"
                                % (approved_tree[:12], local_head_tree[:12], diff_files)
                            )
        else:
            if range_end == TO:
                tree_ok = True
            else:
                diff_result = run_git(["diff", "--name-only", range_end, TO])
                if diff_result.returncode != 0:
                    errors.append(
                        "range_end_sha (%s)..push HEAD (%s) diff failed"
                        % (range_end[:12], TO[:12])
                    )
                else:
                    diff_files = sorted(f for f in diff_result.stdout.strip().split("\n") if f)
                    allowed = ["docs/LAST_APPROVED_VERDICT.json", "docs/LAST_REVIEWED_SHA.txt"]
                    if diff_files and all(f in allowed for f in diff_files):
                        tree_ok = True
                    else:
                        errors.append(
                            "range_end_sha (%s) != push HEAD (%s); diff: %s"
                            % (range_end[:12], TO[:12], diff_files)
                        )
    except Exception as exc:
        errors.append("gate check failed: %s" % exc)

if not tree_ok and not errors:
    errors.append("verdict does not cover push HEAD (tree or range_end mismatch)")

# 3. simulated must be exactly False
if v.get("simulated") is not False:
    errors.append("simulated is not false — simulated verdicts NEVER satisfy the gate")

# 4. engine must be non-empty and not placeholder
engine = v.get("engine", "")
if not engine or engine == "none":
    errors.append("engine is missing or placeholder")

# 5. HMAC signature verification (fail-closed if key missing)
hmac_key = os.environ.get("VERDICT_HMAC_KEY", "")
if not hmac_key:
    errors.append(
        "VERDICT_HMAC_KEY not set — fail-closed. "
        "Set the env var to verify verdict signature."
    )
else:
    sig = v.get("signature", "")
    if not sig:
        errors.append("signature field is empty")
    else:
        payload = {k: val for k, val in sorted(v.items()) if k != "signature"}
        canonical = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode()
        expected = hmac.new(hmac_key.encode(), canonical, hashlib.sha256).hexdigest()
        if not hmac.compare_digest(expected, sig):
            errors.append("HMAC signature mismatch — verdict may be tampered")

if errors:
    print("", file=sys.stderr)
    print("========================================", file=sys.stderr)
    print("  PUSH BLOCKED — verdict gate failed", file=sys.stderr)
    print("========================================", file=sys.stderr)
    for e in errors:
        print("  • %s" % e, file=sys.stderr)
    print("", file=sys.stderr)
    print("  Fix: ./ops/ship.sh", file=sys.stderr)
    print("", file=sys.stderr)
    sys.exit(1)

print("  All gate checks passed.")
PYEOF

if [ "$GATE_RC" -ne 0 ]; then
  exit 1
fi

echo "pre-push: APPROVED verdict validated (ship-only + HMAC). Push allowed."
exit 0
