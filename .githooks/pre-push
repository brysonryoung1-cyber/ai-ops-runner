#!/usr/bin/env bash
# pre-push — UNBREAKABLE PUSH GATE (v2: ship-only + HMAC + canonical verdict)
#
# A push to origin/main requires ALL of:
#   1. OPENCLAW_SHIP=1 env var (set only by ops/ship.sh)
#   2. docs/LAST_APPROVED_VERDICT.json exists and is committed
#   3. range_end_sha == approved_head_sha (internal consistency)
#   4. range_end_sha matches the push HEAD:
#      - EXACT: range_end_sha == push HEAD, OR
#      - EXTENSION: range_end_sha == parent(push HEAD) and the only
#        diff is docs/LAST_APPROVED_VERDICT.json and/or docs/LAST_REVIEWED_SHA.txt
#   5. simulated == false
#   6. HMAC signature valid (fail-closed if VERDICT_HMAC_KEY unset)
#
# NO bypass env vars. NO direct git push. Simulated verdicts NEVER pass.
set -euo pipefail

ROOT_DIR="$(git rev-parse --show-toplevel)"

# ── Gate 0: Ship-only enforcement ──
if [ "${OPENCLAW_SHIP:-0}" != "1" ]; then
  echo "" >&2
  echo "========================================" >&2
  echo "  PUSH BLOCKED — direct push forbidden" >&2
  echo "========================================" >&2
  echo "  Only ops/ship.sh may push to main." >&2
  echo "  Run:  ./ops/ship.sh" >&2
  echo "" >&2
  exit 1
fi

# ── Read stdin (git push protocol) ──
PUSH_LOCAL_SHA=""
PUSH_REMOTE_SHA=""
while read -r local_ref local_sha remote_ref remote_sha; do
  if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
    continue
  fi
  if [ "$remote_ref" = "refs/heads/main" ]; then
    PUSH_LOCAL_SHA="$local_sha"
    PUSH_REMOTE_SHA="$remote_sha"
  fi
done

if [ -z "$PUSH_LOCAL_SHA" ]; then
  exit 0
fi

TO="$PUSH_LOCAL_SHA"
echo "pre-push: Checking canonical verdict for push HEAD ${TO:0:12}"

# ── Load canonical verdict ──
VERDICT_PATH="$ROOT_DIR/docs/LAST_APPROVED_VERDICT.json"
if [ ! -f "$VERDICT_PATH" ]; then
  echo "" >&2
  echo "========================================" >&2
  echo "  PUSH BLOCKED — docs/LAST_APPROVED_VERDICT.json not found" >&2
  echo "========================================" >&2
  echo "  Run:  ./ops/ship.sh" >&2
  echo "" >&2
  exit 1
fi

# ── Strict gate validation (Python) ──
GATE_RC=0
python3 - "$VERDICT_PATH" "$TO" <<'PYEOF' || GATE_RC=$?
import json, sys, os, hmac, hashlib, subprocess

verdict_path = sys.argv[1]
TO = sys.argv[2]

with open(verdict_path) as f:
    v = json.load(f)

errors = []

# 1. Internal consistency: approved_head_sha == range_end_sha
approved = v.get("approved_head_sha", "")
range_end = v.get("range_end_sha", "")
if approved != range_end:
    errors.append(
        "internal inconsistency: approved_head_sha (%s) != range_end_sha (%s)"
        % (approved[:12], range_end[:12])
    )

# 2. Range match: range_end_sha must match push HEAD or be its parent
#    with only verdict/baseline files in the diff.
range_ok = False
if range_end == TO:
    range_ok = True
else:
    try:
        result = subprocess.run(
            ["git", "diff", "--name-only", range_end, TO],
            capture_output=True, text=True, timeout=10
        )
        diff_files = sorted(f for f in result.stdout.strip().split("\n") if f)
        allowed = sorted(["docs/LAST_APPROVED_VERDICT.json", "docs/LAST_REVIEWED_SHA.txt"])
        if diff_files and all(f in allowed for f in diff_files):
            range_ok = True
        elif diff_files:
            errors.append(
                "range_end_sha (%s) != push HEAD (%s) and diff contains non-verdict files: %s"
                % (range_end[:12], TO[:12], diff_files)
            )
        else:
            errors.append(
                "range_end_sha (%s) != push HEAD (%s) and git diff failed"
                % (range_end[:12], TO[:12])
            )
    except Exception as exc:
        errors.append("range check failed: %s" % exc)

if not range_ok:
    errors.append(
        "range_end_sha (%s) does not match push HEAD (%s)"
        % (range_end[:12], TO[:12])
    )

# 3. simulated must be exactly False
if v.get("simulated") is not False:
    errors.append("simulated is not false — simulated verdicts NEVER satisfy the gate")

# 4. engine must be non-empty and not placeholder
engine = v.get("engine", "")
if not engine or engine == "none":
    errors.append("engine is missing or placeholder")

# 5. HMAC signature verification (fail-closed if key missing)
hmac_key = os.environ.get("VERDICT_HMAC_KEY", "")
if not hmac_key:
    errors.append(
        "VERDICT_HMAC_KEY not set — fail-closed. "
        "Set the env var to verify verdict signature."
    )
else:
    sig = v.get("signature", "")
    if not sig:
        errors.append("signature field is empty")
    else:
        payload = {k: val for k, val in sorted(v.items()) if k != "signature"}
        canonical = json.dumps(payload, sort_keys=True, separators=(",", ":")).encode()
        expected = hmac.new(hmac_key.encode(), canonical, hashlib.sha256).hexdigest()
        if not hmac.compare_digest(expected, sig):
            errors.append("HMAC signature mismatch — verdict may be tampered")

if errors:
    print("", file=sys.stderr)
    print("========================================", file=sys.stderr)
    print("  PUSH BLOCKED — verdict gate failed", file=sys.stderr)
    print("========================================", file=sys.stderr)
    for e in errors:
        print("  • %s" % e, file=sys.stderr)
    print("", file=sys.stderr)
    print("  Fix: ./ops/ship.sh", file=sys.stderr)
    print("", file=sys.stderr)
    sys.exit(1)

print("  All gate checks passed.")
PYEOF

if [ "$GATE_RC" -ne 0 ]; then
  exit 1
fi

echo "pre-push: APPROVED verdict validated (ship-only + HMAC). Push allowed."
exit 0
