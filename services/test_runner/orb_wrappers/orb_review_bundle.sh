#!/usr/bin/env bash
# orb_review_bundle.sh — Run ORB repo's review_bundle.sh in read-only worktree.
# Called by executor with cwd = worktree.
# Env vars (set by executor): ARTIFACT_DIR, SINCE_SHA (optional)
#
# Test-only env:
#   FORCE_SIZE_CAP=1  — skip the actual bundle and simulate exit code 6
#                       (deterministic testing of the SIZE_CAP fallback path).
#                       This var is NOT in the job allowlist's allowed_params,
#                       so the executor will never inject it from API params.
set -euo pipefail

SINCE_SHA="${SINCE_SHA:-}"
FORCE_SIZE_CAP="${FORCE_SIZE_CAP:-0}"
OUT="$ARTIFACT_DIR/REVIEW_BUNDLE.txt"

echo "==> orb_review_bundle"
echo "    cwd=$(pwd)"
echo "    artifact_dir=$ARTIFACT_DIR"

# Determine --since SHA
if [ -z "$SINCE_SHA" ]; then
  if [ -f docs/LAST_REVIEWED_SHA.txt ]; then
    SINCE_SHA="$(tr -d '[:space:]' < docs/LAST_REVIEWED_SHA.txt)"
    echo "    since_sha=$SINCE_SHA (from docs/LAST_REVIEWED_SHA.txt)"
  else
    SINCE_SHA="$(git rev-list --max-parents=0 HEAD | head -1)"
    echo "    since_sha=$SINCE_SHA (first commit — no LAST_REVIEWED_SHA.txt)"
  fi
else
  echo "    since_sha=$SINCE_SHA (from params)"
fi

# Check for review_bundle.sh (or FORCE_SIZE_CAP test mode)
if [ -f ./ops/review_bundle.sh ] || [ "$FORCE_SIZE_CAP" = "1" ]; then
  RC=0
  if [ "$FORCE_SIZE_CAP" = "1" ]; then
    echo "==> FORCE_SIZE_CAP enabled (test mode) — simulating exit code 6"
    echo "FORCE_SIZE_CAP: simulated SIZE_CAP_EXCEEDED" > "$OUT"
    RC=6
  else
    echo "==> Running ./ops/review_bundle.sh --since $SINCE_SHA (stdout -> $OUT)"
    bash ./ops/review_bundle.sh --since "$SINCE_SHA" > "$OUT" || RC=$?
  fi

  if [ "$RC" -ne 0 ]; then
    echo "==> review_bundle.sh exited with code $RC"
    # Exit code 6 means size cap exceeded — generate review packets artifact
    if [ "$RC" -eq 6 ]; then
      echo "    Size cap exceeded; generating review-packet artifact"

      # -- Write SIZE_CAP summary to REVIEW_BUNDLE.txt (existing behaviour) --
      {
        echo "SIZE_CAP_EXCEEDED"
        echo ""
        echo "=== FILE LIST ==="
        git diff --name-status "$SINCE_SHA" HEAD 2>/dev/null || true
      } > "$OUT"

      # -------------------------------------------------------------------
      # SIZE_CAP fallback: generate review packets
      # -------------------------------------------------------------------
      STAMP="$(date -u +%Y%m%d_%H%M%S)"
      PACKET_DIR="$ARTIFACT_DIR/review_packets/$STAMP"
      mkdir -p "$PACKET_DIR"

      # --- attempt ORB's review_codex.sh (non-interactive, NO Codex) ------
      PACKETS_GENERATED=0
      if [ -f ./ops/review_codex.sh ]; then
        echo "    Found ./ops/review_codex.sh — attempting packet generation"
        if REVIEW_OUTPUT_DIR="$PACKET_DIR" \
           REVIEW_MODE="FULL" \
           bash ./ops/review_codex.sh \
             --mode FULL --since "$SINCE_SHA" \
             --output-dir "$PACKET_DIR" --no-codex 2>/dev/null; then
          if ls "$PACKET_DIR"/packet_*.txt >/dev/null 2>&1; then
            PACKETS_GENERATED=1
            echo "    review_codex.sh generated packets"
          fi
        fi
      fi

      # --- fallback: generate packets from git diff per-file ---------------
      if [ "$PACKETS_GENERATED" -eq 0 ]; then
        echo "    Generating packets from diff (builtin fallback)"
        CHANGED_FILES="$(git diff --name-only "$SINCE_SHA" HEAD 2>/dev/null || true)"

        if [ -z "$CHANGED_FILES" ]; then
          printf '(no changed files)\n' > "$PACKET_DIR/packet_001.txt"
        else
          PNUM=0
          CUR_FILE=""
          CUR_SIZE=0
          MAX_PACKET_BYTES=50000   # ~50 KB per packet

          while IFS= read -r fname; do
            [ -z "$fname" ] && continue
            FDIFF="$(git diff "$SINCE_SHA" HEAD -- "$fname" 2>/dev/null || true)"
            FSIZE=${#FDIFF}

            if [ "$CUR_SIZE" -eq 0 ] || [ $((CUR_SIZE + FSIZE)) -gt "$MAX_PACKET_BYTES" ]; then
              PNUM=$((PNUM + 1))
              CUR_FILE="$PACKET_DIR/packet_$(printf '%03d' "$PNUM").txt"
              {
                echo "# Review Packet $PNUM"
                echo "# Generated by ai-ops-runner SIZE_CAP fallback"
                echo "# Since: $SINCE_SHA"
                echo ""
              } > "$CUR_FILE"
              CUR_SIZE=0
            fi

            printf '%s\n' "$FDIFF" >> "$CUR_FILE"
            CUR_SIZE=$((CUR_SIZE + FSIZE))
          done <<< "$CHANGED_FILES"

          [ "$PNUM" -eq 0 ] && printf '(no diffs)\n' > "$PACKET_DIR/packet_001.txt"
        fi

        # HOW_TO_PASTE.txt
        cat > "$PACKET_DIR/HOW_TO_PASTE.txt" <<'HOWTO'
HOW TO REVIEW WITH PACKETS
===========================

These packets were generated because the review bundle exceeded the
size cap.  Each packet_NNN.txt contains diffs for a subset of changed
files.

To review:
  1. Open each packet file in order (packet_001.txt, packet_002.txt, …)
  2. Paste the contents into your review tool (Codex, etc.)
  3. Review the diffs in each packet
  4. Combine findings from all packets into a single verdict

Packet generation mode: FULL (all changed files included)
HOWTO
      fi

      # -- tar.gz archive --------------------------------------------------
      if [ -d "$PACKET_DIR" ]; then
        (cd "$ARTIFACT_DIR" && tar -czf ORB_REVIEW_PACKETS.tar.gz "review_packets/$STAMP")
        echo "    ORB_REVIEW_PACKETS.tar.gz created"
      fi

      # -- README -----------------------------------------------------------
      NPACKETS="$(ls -1 "$PACKET_DIR"/packet_*.txt 2>/dev/null | wc -l | tr -d ' ')"
      cat > "$ARTIFACT_DIR/README_REVIEW_PACKETS.txt" <<EOF
ORB Review Packets — SIZE_CAP Fallback
=======================================

The review bundle exceeded the size cap (exit code 6).
Review packets have been generated as a fallback.

Packets:    $NPACKETS
Location:   review_packets/$STAMP/
Archive:    ORB_REVIEW_PACKETS.tar.gz
Since SHA:  $SINCE_SHA

How to review:
  1. Extract the archive or browse review_packets/$STAMP/
  2. Review each packet_NNN.txt file (contains per-file diffs)
  3. See HOW_TO_PASTE.txt in the packets directory for details

Invariants preserved:
  - Worktree was read-only during generation
  - No tracked files were modified
  - Git status remains clean
EOF

      # -- size_cap_meta.json (executor merges this into artifact.json) -----
      cat > "$ARTIFACT_DIR/size_cap_meta.json" <<EOF
{
  "size_cap_triggered": true,
  "size_cap_exceeded": true,
  "warnings": ["SIZE_CAP_EXCEEDED"],
  "review_packets_archive": "ORB_REVIEW_PACKETS.tar.gz",
  "review_packets_dir": "review_packets/$STAMP",
  "packet_dir": "review_packets/$STAMP",
  "archive_path": "ORB_REVIEW_PACKETS.tar.gz",
  "readme_path": "README_REVIEW_PACKETS.txt",
  "packet_count": $NPACKETS,
  "since_sha": "$SINCE_SHA",
  "stamp": "$STAMP"
}
EOF
      echo "    size_cap_meta.json written ($NPACKETS packets)"

      # SIZE_CAP fallback succeeded — exit 0 so job status = success
      # (artifact.json still carries size_cap_exceeded + warnings for callers)
      echo "==> SIZE_CAP fallback artifacts generated successfully — exiting 0"
      exit 0
    fi
    # Non-SIZE_CAP failure — propagate original exit code
    exit $RC
  fi
  echo "==> REVIEW_BUNDLE.txt written ($(wc -c < "$OUT" | tr -d ' ') bytes)"
else
  echo "SCRIPT_NOT_FOUND: ./ops/review_bundle.sh not found in target repo" >&2
  echo "SCRIPT_NOT_FOUND: ./ops/review_bundle.sh" > "$OUT"
  exit 1
fi
